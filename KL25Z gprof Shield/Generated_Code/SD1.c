/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : SD1.c
**     Project     : MCUX_PE_KL25Z_FRTOS_ShieldwFatFS_gprof
**     Processor   : MKL25Z128VLK4
**     Component   : SD_Card
**     Version     : Component 01.185, Driver 01.00, CPU db: 3.00.000
**     Repository  : My Components
**     Compiler    : GNU C Compiler
**     Date/Time   : 2020-01-10, 10:49, # CodeGen: 0
**     Abstract    :
**         Implements interface to SD card for FatFs
**     Settings    :
**          Component name                                 : SD1
**          Block size                                     : 512
**          Cmd wait counter                               : 10
**          Wait Ready Timeout (ms)                        : 500
**          Wait Cmd Timeout (ms)                          : 100
**          Receive Block Timeout (ms)                     : 500
**          SPI Block Transfer                             : no
**          Hardware                                       : 
**            SW SPI                                       : Disabled
**            HW SPI                                       : Enabled
**              Slow Baud Rate Mode                        : 0
**              Fast Baud Rate Mode                        : 1
**              LDD HW SPI                                 : Enabled
**                LDD HW SPI                               : SM2
**              non-LDD HW SPI                             : Disabled
**            SPI Read/Write Macros                        : Disabled
**            Slave Select                                 : Disabled
**            Activate                                     : Disabled
**            Card detection                               : Disabled
**            Report 'Card present' if no Card detection pin: yes
**            Write protection                             : Disabled
**          System                                         : 
**            Wait                                         : WAIT1
**            Timeout                                      : TMOUT1
**            RTOS                                         : Enabled
**              RTOS                                       : FRTOS1
**     Contents    :
**         Activate         - void SD1_Activate(void);
**         Deactivate       - void SD1_Deactivate(void);
**         isWriteProtected - bool SD1_isWriteProtected(void);
**         CardPresent      - bool SD1_CardPresent(void);
**         WaitReady        - uint8_t SD1_WaitReady(void);
**         ReceiveDataBlock - bool SD1_ReceiveDataBlock(uint8_t *data, uint16_t nofBytes);
**         SendDataBlock    - bool SD1_SendDataBlock(uint8_t *data, uint8_t token, uint16_t nofBytes);
**         SendCmd          - uint8_t SD1_SendCmd(uint8_t cmd, uint32_t arg);
**         SetSlowMode      - void SD1_SetSlowMode(void);
**         SetFastMode      - void SD1_SetFastMode(void);
**         InitCommChannel  - void SD1_InitCommChannel(void);
**         Deinit           - uint8_t SD1_Deinit(void* unused);
**         Init             - uint8_t SD1_Init(void* unused);
**
**     * Copyright (c) 2012-2019, Erich Styger
**      * Web:         https://mcuoneclipse.com
**      * SourceForge: https://sourceforge.net/projects/mcuoneclipse
**      * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx
**      * All rights reserved.
**      *
**      * Redistribution and use in source and binary forms, with or without modification,
**      * are permitted provided that the following conditions are met:
**      *
**      * - Redistributions of source code must retain the above copyright notice, this list
**      *   of conditions and the following disclaimer.
**      *
**      * - Redistributions in binary form must reproduce the above copyright notice, this
**      *   list of conditions and the following disclaimer in the documentation and/or
**      *   other materials provided with the distribution.
**      *
**      * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**      * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**      * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**      * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**      * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**      * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**      * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**      * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**      * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
** ###################################################################*/
/*!
** @file SD1.c
** @version 01.00
** @brief
**         Implements interface to SD card for FatFs
*/         
/*!
**  @addtogroup SD1_module SD1 module documentation
**  @{
*/         

/* MODULE SD1. */

#include "SD1.h"
#include "diskio.h"

static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
static uint8_t CardType = CT_SD1;       /* Card type flags */
static uint8_t currentSpeedMode = SD1_ACTIVATE_MODE_NONE; /* current speed mode */

enum { /* SD card response codes */
  SD1_OK = 0,
  SD1_IDLE = 1
};

#define SD1_SPI_WRITE_BLOCK_ENABLED          0
#define SD1_SPI_WRITE_READ_BLOCK_ENABLED     0

/* different wait counters to deal with slow SD cards */
#define SD1_TIMEOUT_READY_MS       500  /* user configured wait timeout until the device is ready */
#define SD1_TIMEOUT_CMD_MS         100  /* user configured wait timeout for commands */
#define SD1_TIMEOUT_READ_BLOCK_MS  500  /* user configured wait timeout for reading a data block */
#define SD1_ENABLE_SS()   /* dummy macro, as not using slave selection */
#define SD1_DISABLE_SS()  /* dummy macro, as not using slave selection */
#define SD1_DUMMY 0xff /* SPI dummy value */

/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
DSTATUS SD1_disk_initialize (
        uint8_t drv                     /* Physical drive number (0..) */
)
{
  uint8_t n, cmd, ty, ocr[4];

  (void)drv; /* not used */
  if (Stat&STA_NODISK) {
    return Stat;                        /* No card in the socket */
  }
  if (SD1_Init(NULL) != ERR_OK) {
    return STA_NOINIT;
  }
  ty = 0;
  if (SD1_SendCmd(SD1_CMD0, 0) == 1) {  /* Enter Idle state */
    if (SD1_SendCmd(SD1_CMD8, 0x1AA) == 1) { /* SDHC */
      for (n = 0; n < 4; n++) {
        ocr[n] = SD1_ReceiveByte();     /* Get trailing return value of R7 resp */
      }
      if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
        while (SD1_SendCmd(SD1_ACMD41, 1UL << 30)) {
          /* Wait for leaving idle state (ACMD41 with HCS bit) */
        }
        if (SD1_SendCmd(SD1_CMD58, 0) == 0) { /* Check CCS bit in the OCR */
          for (n = 0; n < 4; n++) {
            ocr[n] = SD1_ReceiveByte();
          }
          ty = (uint8_t)((ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2); /* SDv2 */
        }
      }
    } else {                            /* SDSC or MMC */
      if (SD1_SendCmd(SD1_ACMD41, 0) <= 1) {
        ty = CT_SD1; cmd = SD1_ACMD41;  /* SDv1 */
      } else {
        ty = CT_MMC; cmd = SD1_CMD1;    /* MMCv3 */
      }
      while (SD1_SendCmd(cmd, 0)) {
        /* Wait for leaving idle state */
      }
      if (SD1_SendCmd(SD1_CMD16, SD1_BLOCK_SIZE) != 0) { /* Set R/W block length  */
        ty = 0;
      }
    }
    SD1_SetFastMode();
  }
  CardType = ty;
  Stat &= ~STA_NOINIT;                  /* Clear STA_NOINIT */
  return Stat;
}

/*-----------------------------------------------------------------------*/
/* Return Disk Status                                                    */
DSTATUS SD1_disk_status (
        uint8_t drv                     /* Physical drive number (0..) */
)
{
  (void)drv; /* not used */
  return Stat;
}

/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
DRESULT SD1_disk_read (
        uint8_t drv,                    /* Physical drive number (0..) */
        uint8_t *buff,                  /* Data buffer to store read data */
        uint32_t sector,                /* Sector address (LBA) */
        unsigned int count              /* Number of sectors to read (1..255) */
)
{
  (void)drv; /* not used */
  if (!count) {
    return RES_PARERR;
  }
  if (Stat & STA_NOINIT) {
    return RES_NOTRDY;
  }
  if (!(CardType & CT_BLOCK)) {
    sector *= SD1_BLOCK_SIZE;           /* Convert to byte address if needed */
  }
  if (count == 1) {                     /* Single block read */
    if (   (SD1_SendCmd(SD1_CMD17, sector) == 0) /* READ_SINGLE_BLOCK */
        && SD1_ReceiveDataBlock(buff, SD1_BLOCK_SIZE))
    {
      count = 0;
    }
  } else {                              /* Multiple block read */
    if (SD1_SendCmd(SD1_CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
      do {
        if (!SD1_ReceiveDataBlock(buff, SD1_BLOCK_SIZE)) {
          break;
        }
        buff += SD1_BLOCK_SIZE;
      } while (--count);
      (void)SD1_SendCmd(SD1_CMD12, 0);  /* STOP_TRANSMISSION */
    }
  }
  return count ? RES_ERROR : RES_OK;
}

/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
#if _READONLY == 0
DRESULT SD1_disk_write (
        uint8_t drv,                    /* Physical drive number (0..) */
        const uint8_t *buff,            /* Data to be written */
        uint32_t sector,                /* Sector address (LBA) */
        unsigned int count              /* Number of sectors to write (1..255) */
)
{
  (void)drv; /* not used */
  if (!count) {
    return RES_PARERR;
  }
  if (Stat & STA_NOINIT) {
    return RES_NOTRDY;
  }
  if (Stat & STA_PROTECT) {
    return RES_WRPRT;
  }
  if (!(CardType & CT_BLOCK)) {
    sector *= SD1_BLOCK_SIZE;           /* Convert to byte address if needed */
  }
  if (count == 1) {                     /* Single block write */
    if (  (SD1_SendCmd(SD1_CMD24, sector) == 0) /* WRITE_BLOCK */
        && SD1_SendDataBlock((uint8_t*)buff, 0xFE, SD1_BLOCK_SIZE))
    {
      count = 0;
    }
  } else {                              /* Multiple block write */
    if (CardType & CT_SDC) {
      (void)SD1_SendCmd(SD1_ACMD23, count);
    }
    if (SD1_SendCmd(SD1_CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
      do {
        if (!SD1_SendDataBlock((uint8_t*)buff, 0xFC, SD1_BLOCK_SIZE)) {
          break;
        }
        buff += SD1_BLOCK_SIZE;
      } while (--count);
      if (!SD1_SendDataBlock(0, 0xFD, SD1_BLOCK_SIZE)) { /* STOP_TRAN token */
        count = 1;
      }
    }
  }
  return count ? RES_ERROR : RES_OK;
}
#endif /* _READONLY */
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
static uint8_t chk_power(void) { return 1;}
static void power_off(void) {}
static void power_on(void) {}
/*-----------------------------------------------------------------------*/
DRESULT SD1_disk_ioctl (
        uint8_t drv,                    /* Physical drive number (0..) */
        uint8_t ctrl,                   /* Control code */
        void *buff                      /* Buffer to send/receive control data */
)
{
  DRESULT res = RES_OK;
  uint8_t n, csd[16], *ptr = (uint8_t*)buff;
  uint16_t csize;

  (void)drv; /* not used */
  if (ctrl == CTRL_POWER) {
    switch (*ptr) {
      case 0:                           /* Sub control code == 0 (POWER_OFF) */
        if (chk_power()) {
        /*lint -save -e522 Highest operation lacks side effect */
          power_off();                  /* Power off */
        /*lint -restore */
        }
        break;
      case 1:                           /* Sub control code == 1 (POWER_ON) */
        /*lint -save -e522 Highest operation lacks side effect */
        power_on();                     /* Power on */
        /*lint -restore */
        break;
      case 2:                           /* Sub control code == 2 (POWER_GET) */
        *(ptr+1) = (uint8_t)chk_power();
        break;
      default:
        res = RES_PARERR;
    } /* switch */
  } else {
    if (Stat & STA_NOINIT) {
      return RES_NOTRDY;
    }
    switch (ctrl) {
      case CTRL_SYNC :                  /* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
        if (SD1_WaitReady() != ERR_OK) {
          res = RES_ERROR;
        }
        break;
      case MMC_GET_READ_BL_LEN:         /* get Block Length */
        if ((SD1_SendCmd(SD1_CMD9, 0) == 0) && SD1_ReceiveDataBlock(csd, 16)) {
          switch((csd[5]&15)) {         /* READ_BL_LEN is either 9, 10 or 11, end the block size is 2^READ_BL_LEN */
            case 9: *(uint16_t*)ptr = 512; break;
            case 10: *(uint16_t*)ptr = 1024; break;
            case 11: *(uint16_t*)ptr = 2048; break;
            default: *(uint16_t*)ptr = 0; break; /* illegal */
          }
        }
        break;
      case MMC_GET_SDC_VERSION:         /* get CSD Version (1 byte: 1 for 1.xx or MMC, 2 for 2.0 */
        if ((SD1_SendCmd(SD1_CMD9, 0) == 0) && SD1_ReceiveDataBlock(csd, 16)) {
          if ((csd[0] >> 6) == 1) {     /* SDC ver 2.00 */
            *ptr = 2;
          } else {                      /* SDC ver 1.XX or MMC*/
            *ptr = 1;
          }
        }
        break;
      case GET_SECTOR_COUNT :           /* Get number of sectors on the disk (uint32_t) */
        if ((SD1_SendCmd(SD1_CMD9, 0) == 0) && SD1_ReceiveDataBlock(csd, 16)) {
          if ((csd[0] >> 6) == 1) {     /* SDC ver 2.00 */
            csize = (uint16_t)(csd[9] + ((uint16_t)csd[8] << 8) + 1);
            *(uint32_t*)buff = (uint32_t)csize << 10;
          } else {                      /* SDC ver 1.XX or MMC*/
            n = (uint8_t)((csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2);
            csize = (uint16_t)((csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 3) << 10) + 1);
            *(uint32_t*)buff = (uint32_t)csize << (uint8_t)(n - 9);
          }
        }
        break;
      case GET_SECTOR_SIZE :            /* Get R/W sector size (uint16_t) */
        *(uint16_t*)buff = SD1_BLOCK_SIZE;
        break;
      case GET_BLOCK_SIZE :             /* Get erase block size in unit of sector (uint32_t) */
        if (CardType & CT_SD2) {        /* SDC ver 2.00 */
          if (SD1_SendCmd(SD1_ACMD13, 0) == 0) { /* Read SD status */
            (void)SD1_ReceiveByte();
            if (SD1_ReceiveDataBlock(csd, 16)) { /* Read partial block */
              for (n = 64 - 16; n; n--) {
                (void)SD1_ReceiveByte(); /* Purge trailing data */
              }
              *(uint32_t*)buff = 16UL << (csd[10] >> 4);
            }
          }
        } else {                        /* SDC ver 1.XX or MMC */
          if ((SD1_SendCmd(SD1_CMD9, 0) == 0) && SD1_ReceiveDataBlock(csd, 16)) {        /* Read CSD */
            if (CardType & CT_SD1) {    /* SDC ver 1.XX */
              *(uint32_t*)buff = (uint32_t)((((csd[10] & 63) << 1) + ((uint16_t)(csd[11] & 128) >> 7) + 1) << (uint8_t)((csd[13] >> 6) - 1));
            } else {                    /* MMC */
              *(uint32_t*)buff = (uint32_t)(((uint16_t)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1));
            }
          }
        }
        break;
      case MMC_GET_TYPE :               /* Get card type flags (1 byte) */
        *ptr = CardType;
        break;

      case MMC_GET_CSD :                /* Receive CSD as a data block (16 bytes) */
         if (!(SD1_SendCmd(SD1_CMD9, 0) == 0 /* READ_CSD */
            && SD1_ReceiveDataBlock(ptr, 16)))
         {
           res = RES_PARERR;
         }
         break;
      case MMC_GET_CID :                /* Receive CID as a data block (16 bytes) */
        if (!(SD1_SendCmd(SD1_CMD10, 0) == 0 /* READ_CID */
            && SD1_ReceiveDataBlock(ptr, 16)))
        {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_OCR :                /* Receive OCR as an R3 resp (4 bytes) */
        if (SD1_SendCmd(SD1_CMD58, 0) == 0) { /* READ_OCR */
          for (n = 4; n; n--) {
            *ptr++ = SD1_ReceiveByte();
          }
        } else {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_SDSTAT :             /* Receive SD status as a data block (64 bytes) */
        if (SD1_SendCmd(SD1_ACMD13, 0) == 0) { /* SD_STATUS */
          (void)SD1_ReceiveByte();
          if (!SD1_ReceiveDataBlock(ptr, 64)) {
            res = RES_PARERR;
          }
        } else {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_DRIVER_VERSION:      /* 1 byte: return: 0 SPI driver, 1 LLD SDHC driver */
        *ptr = 0;
        break;

      default:
        res = RES_PARERR;
    } /* switch */
  } /* if-else */
  return res;
}

#define SD1_SPI_Enable()                   (void)SM2_Enable(SM2_DeviceData)
#define SD1_SPI_Disable()                  (void)SM2_Disable(SM2_DeviceData)
#define SD1_SPI_SetSlowMode()              (void)SM2_SelectConfiguration(SM2_DeviceData, 0, 0) /* max 400kbps */
#define SD1_SPI_SetFastMode()              (void)SM2_SelectConfiguration(SM2_DeviceData, 1, 1) /* max 12Mbps */
#define SD1_SPI_SetShiftClockPolarity(val) /* not needed for LDD */
#define SD1_SPI_SetIdleClockPolarity(val)  /* not needed for LDD */

static volatile bool SD1_DataReceivedFlag = FALSE;

void SD1_SPI_WRITE(unsigned char write) {
  unsigned char dummy;

  SD1_DataReceivedFlag = FALSE;
  (void)SM2_ReceiveBlock(SM2_DeviceData, &dummy, sizeof(dummy));
  (void)SM2_SendBlock(SM2_DeviceData, &write, sizeof(write));
  while(!SD1_DataReceivedFlag){}
}

#if SD1_SPI_WRITE_BLOCK_ENABLED
static void SD1_SPI_WRITE_BLOCK(unsigned char *writeP, uint16_t size) {
  unsigned char dummy[4];
  uint16_t writeSize;

  while(size>0) {
    if (size>sizeof(dummy)) {
      writeSize = sizeof(dummy);
    } else {
      writeSize = size;
    }
    SD1_DataReceivedFlag = FALSE;
    (void)SM2_ReceiveBlock(SM2_DeviceData, &dummy[0], writeSize);
    (void)SM2_SendBlock(SM2_DeviceData, writeP, writeSize);
    while(!SD1_DataReceivedFlag){}
    size -= writeSize;
    writeP += writeSize;
  }
}
#endif /* SD1_SPI_WRITE_BLOCK_ENABLED */

static void SD1_SPI_WRITE_READ(unsigned char write, unsigned char *readP) {
  SD1_DataReceivedFlag = FALSE;
  (void)SM2_ReceiveBlock(SM2_DeviceData, readP, 1);
  (void)SM2_SendBlock(SM2_DeviceData, &write, 1);
  while(!SD1_DataReceivedFlag){}
}

#if SD1_SPI_WRITE_READ_BLOCK_ENABLED
static void SD1_SPI_WRITE_READ_BLOCK(unsigned char *writeP, unsigned char *readP, uint16_t size) {
  SD1_DataReceivedFlag = FALSE;
  (void)SM2_ReceiveBlock(SM2_DeviceData, readP, size);
  (void)SM2_SendBlock(SM2_DeviceData, writeP, size);
  while(!SD1_DataReceivedFlag){}
}
#endif /* SD1_SPI_WRITE_READ_BLOCK_ENABLED */


#if SD1_SPI_WRITE_BLOCK_ENABLED || SD1_SPI_WRITE_READ_BLOCK_ENABLED
#if SD1_BLOCK_SIZE==512
  #define SPI_WRITE_READ_BLOCK_SIZE_DUMMY 512 /* 512 bytes of dummy values */
  static const uint8_t dummyArr[SPI_WRITE_READ_BLOCK_SIZE_DUMMY] = {
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY
  };
#elif SD1_BLOCK_SIZE==1024
  #define SPI_WRITE_READ_BLOCK_SIZE_DUMMY 1024 /* 1024 bytes of dummy values */
  static const uint8_t dummyArr[SPI_WRITE_READ_BLOCK_SIZE_DUMMY] = {
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY,
    SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY, SD1_DUMMY
  };
#else
  #error "only 512 and 1024 block size supported"
#endif
#endif

/* Internal method prototypes */
static uint8_t SendCommand(uint8_t cmd, uint8_t *arg, uint8_t response);

/*
** ===================================================================
**     Method      :  SD1_Activate (component SD_Card)
**     Description :
**         If multiple devices are used on the same SPI bus, then the
**         device needs to be activated. That way, the different SPI
**         protocol is selected.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void SD1_Activate(void)
{
  /* Note that the SD card SPI interface is defined with 'clock idle low polarity' and 'data shift on rising edge',
   * typically defined as well as 'Mode 0' (CPHA=0, CPOL=0). See http://elm-chan.org/docs/mmc/mmc_e.html
   */
  SD1_InitCommChannel();
  SD1_ENABLE_SS();                      /* select slave */
}

/*
** ===================================================================
**     Method      :  SD1_Deactivate (component SD_Card)
**     Description :
**         Removes/deactivates the card from the bus
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void SD1_Deactivate(void)
{
  SD1_DISABLE_SS();                     /* de-select slave */
}

/*
** ===================================================================
**     Method      :  SD1_WaitReady (component SD_Card)
**     Description :
**         Wait until the card is ready
**     Parameters  : None
**     Returns     :
**         ---             - Error code
**                           ERR_OK: device is ready
**                           ERR_BUSY: device is still busy
** ===================================================================
*/
uint8_t SD1_WaitReady(void)
{
  uint8_t tmp;
  TMOUT1_CounterHandle timeout;

  SD1_Activate();
  SD1_SPI_WRITE(SD1_DUMMY);
  timeout = TMOUT1_GetCounter(SD1_TIMEOUT_READY_MS/TMOUT1_TICK_PERIOD_MS); /* set up timeout counter */
  for (;;) {                            /* will timeout */
    SD1_SPI_WRITE_READ(SD1_DUMMY, &tmp); /* write dummy value, read status */
    if (tmp==0xff) {
      break;
    }
    if (TMOUT1_CounterExpired(timeout)) {
      break;
    }
  } /* for */
  TMOUT1_LeaveCounter(timeout);
  SD1_Deactivate();
  if (tmp==0xff) {
    return ERR_OK; /* device is ready */
  } else {
    return ERR_BUSY;
  }
}

/*
** ===================================================================
**     Method      :  SD1_ReceiveDataBlock (component SD_Card)
**     Description :
**         Retrieve a data block from the device
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to data buffer
**         nofBytes        - number of bytes to retrieve,
**                           must be a multiple of 4
**     Returns     :
**         ---             - TRUE if reading was going fine, FALSE
**                           otherwise.
** ===================================================================
*/
bool SD1_ReceiveDataBlock(uint8_t *data, uint16_t nofBytes)
{
  uint8_t tmp;
  TMOUT1_CounterHandle timeout;
  word cnt = 512; /* polling counter */

  SD1_Activate();
  /* poll response */
  do {
    SD1_SPI_WRITE_READ(SD1_DUMMY, &tmp); /* send dummy value, poll response */
    cnt--;
  } while (tmp==0xFF && cnt>0);
  if (tmp==0xFF) { /* polling not successful, now poll for a longer period of time */
    timeout = TMOUT1_GetCounter(SD1_TIMEOUT_READ_BLOCK_MS/TMOUT1_TICK_PERIOD_MS); /* timeout */
    for (;;) {                          /* will timeout */
      SD1_SPI_WRITE_READ(SD1_DUMMY, &tmp); /* send dummy value, poll response */
      if (tmp!=0xFF) {
        break;
      }
      if (TMOUT1_Value(timeout)!=(SD1_TIMEOUT_READ_BLOCK_MS/TMOUT1_TICK_PERIOD_MS)) {
        /* polled already for a tick period: use RTOS wait in order to balance CPU cycles */
        FRTOS1_vTaskDelay(portTICK_PERIOD_MS);
      }
      if (TMOUT1_CounterExpired(timeout)) {
        break;
      }
    } /* for */
    TMOUT1_LeaveCounter(timeout);
  } /* if */
  if (tmp != 0xFE) {                    /* if it is not expected response, return with error */
    SD1_Deactivate();
    return FALSE;
  }
  /*lint -save -e539 Did not expect positive indentation  */
#if SD1_SPI_WRITE_READ_BLOCK_ENABLED
  if (nofBytes<=SPI_WRITE_READ_BLOCK_SIZE_DUMMY) {
    SD1_SPI_WRITE_READ_BLOCK((unsigned char*)&dummyArr[0], data, nofBytes); /* write dummy value, read data */
  } else {
#endif
    while(nofBytes>0) {
      SD1_SPI_WRITE_READ(SD1_DUMMY, data); /* write dummy value, read data */
      data++;
      nofBytes--;
    }
#if SD1_SPI_WRITE_READ_BLOCK_ENABLED
  }
#endif
  /*lint -restore Did not expect positive indentation */
  SD1_SPI_WRITE(SD1_DUMMY);             /* checksum Bytes not needed */
  SD1_SPI_WRITE(SD1_DUMMY);
  SD1_Deactivate();
  return TRUE;
}

/*
** ===================================================================
**     Method      :  SD1_SendDataBlock (component SD_Card)
**     Description :
**         Send a data block to the device
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to data blocks with 512 bytes
**                           each
**         token           - data/stop token
**         nofBytes        - Number of bytes to send
**     Returns     :
**         ---             - Returns TRUE for success, FALSE for
**                           failure.
** ===================================================================
*/
bool SD1_SendDataBlock(uint8_t *data, uint8_t token, uint16_t nofBytes)
{
  uint8_t resp;

  if (SD1_WaitReady()!=ERR_OK) {
    return FALSE;                       /* device not ready */
  }
  SD1_Activate();
  SD1_SPI_WRITE(token);                 /* Xmit data token */
  if (token != 0xFD) {                  /* Is data token, not STOP_TRAN */
#if SD1_SPI_WRITE_BLOCK_ENABLED
    SD1_SPI_WRITE_BLOCK(data, nofBytes);
#else
    while (nofBytes!=0) {               /* send the bytes */
      SD1_SPI_WRITE(*data);
      data++;
      nofBytes--;
    }
#endif
    SD1_SPI_WRITE(SD1_DUMMY);           /* CRC (Dummy) */
    SD1_SPI_WRITE(SD1_DUMMY);           /* CRC (Dummy) */
    SD1_SPI_WRITE_READ(SD1_DUMMY, &resp); /* write dummy value, receive data response */
    if ((resp&0x1F) != 0x05) {          /* If not accepted, return with error */
      SD1_Deactivate();
      return FALSE;
    }
    /* if we do not poll the device for its busy state, we need to provide at least 8 clocks (dummy cycle).
     * See http://elm-chan.org/docs/mmc/mmc_e.html:
     *    In principle of the SPI mode, the CS signal must be asserted during a transaction,
     *    however there is an exception to this rule. When the card is busy, the host controller
     *    can deassert CS to release SPI bus for any other SPI devices. The card will drive DO signal
     *    low again when reselect it during internal process is in progress.
     *    Therefore a preceding busy check (wait ready immediately before command and data packet)
     *    instead of post wait can eliminate waste wait time. In addition the internal process is initiated
     *    a byte after the data response, this means eight clocks are required to initiate internal write operation.
     */
    SD1_SPI_WRITE(SD1_DUMMY);
  }
  SD1_Deactivate();
  return TRUE;
}

/*
** ===================================================================
**     Method      :  SD1_SendCmd (component SD_Card)
**     Description :
**         Sends a command to the device and returns the response
**     Parameters  :
**         NAME            - DESCRIPTION
**         cmd             - Command to send
**         arg             - command argument
**     Returns     :
**         ---             - device response
** ===================================================================
*/
uint8_t SD1_SendCmd(uint8_t cmd, uint32_t arg)
{
  uint8_t n, res;
  TMOUT1_CounterHandle timeout;

  if (cmd&0x80) {                       /* ACMD<n> is the command sequence of CMD55-CMD<n> */
    cmd &= 0x7F;
    res = SD1_SendCmd(SD1_CMD55, 0);
    if (res > 1) {
      return res;
    }
  }
  /* Select the card and wait for ready */
  if (SD1_WaitReady() != ERR_OK) {
    return 0xFF;
  }
  SD1_Activate();
  /* Send command packet */
  SD1_SPI_WRITE(cmd);                   /* Start + Command index */
  n = (uint8_t)(arg>>24);
  SD1_SPI_WRITE(n);                     /* Argument[31..24] */
  n = (uint8_t)(arg>>16);
  SD1_SPI_WRITE(n);                     /* Argument[23..16] */
  n = (uint8_t)(arg>>8);
  SD1_SPI_WRITE(n);                     /* Argument[15..8] */
  SD1_SPI_WRITE((uint8_t)arg);          /* Argument[7..0] */
  if (cmd == SD1_CMD0) {
    n = 0x95;                           /* Valid CRC for CMD0(0) */
  } else if (cmd == SD1_CMD8) {
    n = 0x87;                           /* Valid CRC for CMD8(0x1AA) */
  } else {
    n = 0x01;                           /* Dummy CRC + Stop */
  }
  SD1_SPI_WRITE(n);
  /* Receive command response */
  if (cmd == SD1_CMD12) {
    SD1_SPI_WRITE_READ(SD1_DUMMY, &res); /* send dummy value, poll response */
  }
  timeout = TMOUT1_GetCounter(SD1_TIMEOUT_CMD_MS/TMOUT1_TICK_PERIOD_MS); /* timeout */
  for(;;) {                            /* will timeout */
    SD1_SPI_WRITE_READ(SD1_DUMMY, &res); /* send dummy value, poll response */
    if (!(res&0x80)) {                 /* valid response */
      break;
    }
    if (TMOUT1_CounterExpired(timeout)) {
      break;
    }
  }
  TMOUT1_LeaveCounter(timeout);
  SD1_Deactivate();
  return res;                           /* Return with the response value */
}
/*
** ===================================================================
**     Method      :  SD1_isWriteProtected (component SD_Card)
**     Description :
**         Determines if the card is write protected. Note that this is
**         an indicator only, as it is still possible to write to the
**         card even if the write protection is set on the card!
**     Parameters  : None
**     Returns     :
**         ---             - True if the card has the write protection
**                           set, false otherwise
** ===================================================================
*/
/*
bool SD1_isWriteProtected(void)
{
  *** method is implemented as macro in the header file
}
*/

/*
** ===================================================================
**     Method      :  SendCommand (component SD_Card)
**
**     Description :
**         Sends a command to the SD card
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint8_t SendCommand(uint8_t cmd, uint8_t *arg, uint8_t response)
{
  #define NOF_WAIT_ITERATIONS 3
  uint8_t u8Temp=0;
  uint8_t u8Counter;

  SD1_Activate();
  SD1_SPI_WRITE(cmd);                   /* Send Start byte */
  /* Send Argument */
  for(u8Counter=0; u8Counter<4; u8Counter++) {
    SD1_SPI_WRITE(arg[u8Counter]);
  }
  SD1_SPI_WRITE(0x95);                  /* Send CRC */
  /* Response Handler */
  for (u8Counter=0;u8Counter<NOF_WAIT_ITERATIONS;u8Counter++) {
    SD1_SPI_WRITE_READ(SD1_DUMMY, &u8Temp); /* send dummy value, poll response */
    if (u8Temp==response) {
      break;
    }
  } /* for */
  SD1_Deactivate();
  if (u8Temp==response) {
    return ERR_OK;
  } else {
    return ERR_FAULT;
  }
}

/*
** ===================================================================
**     Method      :  SD1_Init (component SD_Card)
**     Description :
**         Initializes the driver
**     Parameters  :
**         NAME            - DESCRIPTION
**       * unused          - unused parameter
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t SD1_Init(void* unused)
{
  /* The behavior of SD cards in SPI mode is basically the same as for any SPI slave device.
     The maximum transfer rate of the SD card in SPI mode is 25 Mbps, but in the initialization process the
     transfer rate must be less than 375 kbps. This is because the SPI mode of the SD cards is compatible with
     the MMC cards, and MMC cards can only reach 375 kbps. After initialization, the SPI clock can be
     changed to 25 Mbps.
     Note that the SPI interface is defined with 'clock idle low polarity' and 'data shift on rising edge',
     typically defined as well as 'Mode 0' (CPHA=0, CPOL=0). See http://elm-chan.org/docs/mmc/mmc_e.html
   */
  dword arg;
  TMOUT1_CounterHandle timeout;
  bool isTimeout = FALSE;
  uint8_t cnt;

  (void)unused;
  /* -------------------------------- Init & Slow Mode -------------------------------- */
  /* after voltage reaches 2.2V, need to wait at least 1 ms. Then we need to set Data and CS/Chipselect high for at least 74 clocks */
  /*lint -save -e522 function lacks side-effects */
  WAIT1_Waitms(1);                      /* wait at least for 1 ms on insertion and power on */
  /*lint -restore */
  currentSpeedMode = SD1_ACTIVATE_MODE_NONE;
  SD1_Activate();                       /* select slave */
  SD1_SetSlowMode();                    /* set the SPI clock to 375 kbps. This is required for compatibility across a wide range of SD and MMC cards. */
  SD1_DISABLE_SS();                     /* disable slave (CS high) */
  for(cnt=0;cnt<10;cnt++) {             /* send at least 75 SPI clock cycles with the SS signal asserted to ensure that the SD card internal state machine is initialized. */
    SD1_SPI_WRITE(SD1_DUMMY);
  }
  /*lint -save -e522 function lacks side-effects */
  WAIT1_Waitus(50);                     /* need to wait a little bin in order SPI transfer to be finished (need this on CN128, but on others too?) */
  /*lint -restore */
  SD1_Deactivate();
  /* -------------------------------- IDLE Command -------------------------------- */
  arg = 0;
  timeout = TMOUT1_GetCounter(SD1_TIMEOUT_READY_MS/TMOUT1_TICK_PERIOD_MS); /* timeout */
  while (SendCommand(SD1_CMD0, (uint8_t*)&arg, SD1_IDLE) != ERR_OK) {
    if (TMOUT1_CounterExpired(timeout)) {
      isTimeout = TRUE;                /* indicate a timeout */
      break;
    }
  } /* while */
  TMOUT1_LeaveCounter(timeout);
  if (isTimeout) {                      /* timeout */
    return ERR_FAULT;
  }
  /* Send 8 SPI clocks (SS unasserted). */
  SD1_Activate();
  SD1_DISABLE_SS();                     /* disable slave */
  SD1_SPI_WRITE(SD1_DUMMY);             /* dummy SPI cycle */
  SD1_Deactivate();                     /* de-select slave */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  SD1_ReceiveByte (component SD_Card)
**
**     Description :
**         Receives a byte from the SPI bus
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
uint8_t SD1_ReceiveByte(void)
{
  uint8_t data;

  SD1_Activate();
  SD1_SPI_WRITE_READ(SD1_DUMMY, &data); /* send dummy value, poll response */
  SD1_Deactivate();
  return data;
}

/*
** ===================================================================
**     Method      :  SD1_CardPresent (component SD_Card)
**     Description :
**         Returns true in case a card is present. If there is no card
**         detection pin, then this routine will always return true.
**     Parameters  : None
**     Returns     :
**         ---             - Returns true if card is present, false
**                           otherwise.
** ===================================================================
*/
/*
bool SD1_CardPresent(void)
{
  *** method is implemented as macro in the header file
}
*/

/*
** ===================================================================
**     Method      :  SD1_SetSlowMode (component SD_Card)
**     Description :
**         Switches to slow mode SPI communication speed.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void SD1_SetSlowMode(void)
{
  if (currentSpeedMode!=SD1_ACTIVATE_MODE_SLOW) {
    /* not already in slow mode */
#if 0 /* if using LDD component, do not disable the SPI, as SD1_SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
    SD1_SPI_Disable();
#endif
    SD1_SPI_SetSlowMode();              /* the SPI clock is set to the maximum supported by the MCU and allowed by the SD card */
    currentSpeedMode = SD1_ACTIVATE_MODE_SLOW;
#if 0 /* if using LDD component, do not disable the SPI, as SD1_SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
    SD1_SPI_Enable();
#endif
  } /* if */
}

/*
** ===================================================================
**     Method      :  SD1_SetFastMode (component SD_Card)
**     Description :
**         Switches to fast mode SPI communication speed.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void SD1_SetFastMode(void)
{
  if (currentSpeedMode!=SD1_ACTIVATE_MODE_FAST) {
    /* not already in fast mode */
#if 0 /* if using LDD component, do not disable the SPI, as SD1_SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
    SD1_SPI_Disable();
#endif
    SD1_SPI_SetFastMode();              /* the SPI clock is set to the maximum supported by the MCU and allowed by the SD card */
    currentSpeedMode = SD1_ACTIVATE_MODE_FAST;
#if 0 /* if using LDD component, do not disable the SPI, as SD1_SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
    SD1_SPI_Enable();
#endif
  } /* if */
}

/*
** ===================================================================
**     Method      :  SD1_InitCommChannel (component SD_Card)
**     Description :
**         Method to initialize the communication channel. This is
**         needed if the bus to the SD card is shared with other
**         devices.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void SD1_InitCommChannel(void)
{
  /* Settings:
    - 100-400 kHz clock during init, then max 12 MHz
    - Send MSB first
    - Shift clock idle polarity: low
    - Clock edge: falling edge
  */
  if (currentSpeedMode==SD1_ACTIVATE_MODE_FAST) {
    SD1_SetFastMode(); /* use fast mode. */
  } else if (currentSpeedMode==SD1_ACTIVATE_MODE_SLOW) {
    SD1_SetSlowMode(); /* use slow mode. */
  }
}

/*
** ===================================================================
**     Method      :  SD1_Deinit (component SD_Card)
**     Description :
**         Driver deinitialization routine.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * unused          - dummy parameter
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t SD1_Deinit(void* unused)
{
  (void)unused;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  SD1_OnBlockReceived (component SD_Card)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void SM2_OnBlockReceived(LDD_TUserData *UserDataPtr)
{
  /* Calling inherited event */
  (void)UserDataPtr; /* unused */
  SD1_DataReceivedFlag=TRUE;
}

/* END SD1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.5 [05.21]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
